module SHiNKiROU.Minesweeper.Board

open System
open System.Text
open System.Collections.Generic

#region "Types"

/// A number on the minesweeper board: empty, mine, number, invalid
type Number = byte

/// Represents a square with no mines around it.
[<Literal>]
let EMPTY = 0uy

/// Represents a square with a mine in it.
[<Literal>]
let MINE = 9uy

/// Represents an invalid square: Used in an uninitalized board.
[<Literal>]
let INVALID = 10uy

/// Represents the state of the game: playing, win and lose
type BoardState =
  | Normal
  | Solved
  | GameOver

/// Represents the marking of a square: flag, digged (Open) and buried (Close).
type Flag =
  | Close
  | Flag
  | Open

/// Represents an external view of a square
type View =
  | Flagged
  | NotOpened
  | Opened of Number

/// Thrown in some board operations
exception BoardException of string

/// A coordinate
type Coordinate = int * int

/// Represents the information about a square as gathered by a solver
type SolutionSquare =
  | HasMine
  | NoMine
  | Prob of int * int // for precision reasons, I used rational instead of float

/// Represents a list of squares to be flagged/opened or is likely to be a mine as told by a solver
type SolutionList = (SolutionSquare * Coordinate) []

/// Represents a Minesweeper board
type Board = {
  /// Digging part: can change
  Flags : Flag[,]
  /// Numbering part: never change
  Board : byte[,]
  Width : int
  Height : int;
  /// Number of mines
  Count : int;
  mutable State : BoardState
}

#endregion
#region "Random Number Functions"

let rand = new System.Random()
let randInt = rand.Next
let randFloat() = rand.NextDouble()
let coinFlip() = rand.NextDouble() > 0.5

#endregion

let private exc x = raise (BoardException x)

let size (board : Board) = board.Width, board.Height

let private around' board width height x y =
  seq {
    for x1 in [ x - 1; x; x + 1 ] do
      for y1 in [ y - 1; y; y + 1 ] do
        if not(x1 = x && y1 = y) &&
           x1 >= 0 &&
           x1 < width && y1 >= 0 &&
           y1 < height then
          yield x1, y1
  }

/// Returns a sequence of all squares around a coordinate.
let around (board : Board) =
  around' board board.Width board.Height

/// Generates a 2D boolean array,
/// of the specified number of mines.
let boolBoard w h c cx cy =
  let board = Array2D.zeroCreate w h
  let mutable i = 0
  while i < c do
    let x, y = randInt(w), randInt(h)
    // if not around the initial dig AND the current square is empty
    if not((x = cx - 1 || x = cx || x = cx + 1) &&
           (y = cy - 1 || y = cy || y = cy + 1)) && not(board.[x, y]) then
      board.[x, y] <- true
      i <- i + 1
  board

/// Internal: Label the board generated by boolBoard with numbers.
let labeledBoard width height (board : bool[,]) =
  Array2D.mapi (fun x y v ->
    if v then MINE
    else
      let mutable i = EMPTY
      for x1, y1 in around' board width height x y do
        if board.[x1, y1] then
          i <- i + 1uy
      i
  ) board

/// Checks coordinate of the square being operated on
let checkIndex x y board =
  let w, h = size board
  if x >= w || y >= h then
    exc (sprintf "Index out of range: %d %d." x y)

/// Returns the public information of the board.
let view (board : Board) =
  Array2D.init board.Width board.Height (fun x y ->
    match board.Flags.[x, y], board.Board.[x, y] with
    | Flag, _ -> Flagged
    | Close, _ -> NotOpened
    | Open, _ -> Opened board.Board.[x, y]
  )

/// Formats a board into console-friendly text representation.
/// If the first argument, zeroBase is true, the counting
/// scale will start from zero. (otherwise, one)
let textFormat zeroBase (board : Board) =
  let flags, bboard = board.Flags, board.Board
  let width, height = size board
  let str = new StringBuilder("+|")
  let n = if zeroBase then 0 else 1
  for x = 0 to width - 1 do
    str.Append(((x + n) % 10).ToString()) |> ignore

  // x-scale
  str.Append("\n-+")
     .Append(Array.init width (fun _ -> '-'))
     .Append('\n') |> ignore

  let info = view board
  let gO = board.State = BoardState.GameOver

  for y = 0 to height - 1 do
    // y-scale
    str.Append(((y + n) % 10).ToString())
       .Append('|') |> ignore

    // squares
    for x = 0 to width - 1 do
      let isMine = bboard.[x, y] = MINE
      let ch = 
        match info.[x, y] with
        | Flagged -> '#' 
        | NotOpened -> ' '
        | Opened(EMPTY) -> '.'
        | Opened(b) -> b.ToString().[0]
      if gO then
        // if game over: expose mines
        str.Append(
          if isMine then
            if info.[x, y] = Flagged then 'X' // wrong flag
            else '*'
          else ch
        ) |> ignore
      else
        str.Append(ch) |> ignore
    // x
    str.Append(System.Environment.NewLine) |> ignore
  // y
  str.ToString()

/// Checks if p is true for all squares on the board.
let forallSquares p (board : Board) =
  let flags, board = board.Flags, board.Board
  flags
  |> Array2D.mapi (fun a b f -> a, b)
  |> Seq.cast<Coordinate>
  |> Seq.map (fun (x, y) -> p x y (flags.[x, y]) (board.[x, y]))
  |> Seq.tryFindIndex not
  |> (fun x -> x.IsNone)

/// Check if the board is solved.
let solved =
  forallSquares (fun x y flag mine ->
    match mine with
    | MINE -> flag = Flag // if it is a mine: it must be flagged
    | _ -> flag = Open // if it is not a mine: it must be open
  )

let minesRemaining (board : Board) =
  board.Count - (board.Flags
                 |> Array2D.map (function | Flag -> 1 | _ -> 0)
                 |> Seq.cast<int>
                 |> Seq.sum)

/// Returns the number of to be flagged left.
let toBeFlagged (board : Board) =
  board.Flags
  |> Seq.cast<Flag>
  |> Seq.filter (fun x ->
    x = Flag
  )
  |> Seq.length
  |> (-) board.Count

/// Iterates around a square.
let aroundEach f x y (board : Board) =
  for x1, y1 in around board x y do
    f x1 y1 board.Flags.[x1, y1] board.Board.[x1, y1]

let flagsAround x y board =
  let i = ref 0
  aroundEach (fun x y flag mine ->
    if flag = Flag then
      i := !i + 1
  ) x y board
  !i

/// Creates an array of buried squares
let private bury width height = Array2D.create width height Close

/// If the game is over, throw an exception.
let checkState (board : Board) =
  if board.State <> Normal then
    exc (sprintf "Can't change a board with a state of %A" board.State)

#region "Board Operations"

/// Digs a square, returns a list of all changed squares.
let rec probeList x y (board : Board) =
  checkState board
  checkIndex x y board
  let flags, bboard = board.Flags, board.Board
  let width, height = size board
  let changedSquares = ref []

  // Initialize the board if uninitialized.
  if bboard.[0, 0] = INVALID then
    boolBoard width height board.Count x y
    |> labeledBoard width height
    |> Array2D.iteri (fun x y a ->
      bboard.[x, y] <- a
    )

  if flags.[x, y] = Flag then
    // cannot probe flags
    exc (sprintf "Can't probe a(n) %A square." flags.[x, y])
  elif flags.[x, y] = Open then
    // auto-open (mid-click behavior)
    if bboard.[x, y] = byte(flagsAround x y board) then
      aroundEach (fun x y flag mine ->
        if board.State = Normal && flag = Close then
          let _, s = probeList x y board
          changedSquares := s @ !changedSquares
      ) x y board
  else
    // flood fill: open all squares around a zero (blank open) square
    let stack = new Stack<Coordinate>()
    stack.Push(x, y)

    while stack.Count > 0 do
      let x, y = stack.Pop()
      flags.[x, y] <- Open
      changedSquares := (x, y) :: !changedSquares
      if bboard.[x, y] = EMPTY then
        // fill applicable squares around
        aroundEach (fun x1 y1 flag mine ->
          if flag = Close then
            flags.[x1, y1] <- Open
            changedSquares := (x1, y1) :: !changedSquares
            if mine = EMPTY then
              stack.Push(x1, y1)
        ) x y board

  // update game state
  board.State <-
    if bboard.[x, y] = MINE then GameOver
    elif solved board then Solved
    else Normal
  board, !changedSquares

/// Digs a square, without returning the list of changed squares.
let probe x y b = fst (probeList x y b)

/// Flags a square.
let flag x y (board : Board) =
  checkState board
  checkIndex x y board
  let flags = board.Flags
  let flag = flags.[x, y]
  // only flag closed, unflagged squares
  if flag = Close then
    flags.[x, y] <- Flag
  else
    exc "Cannot flag an open or flagged square."
  // update game state
  board.State <-
    if solved board then Solved
    else Normal
  board

/// Unflags a square.
let unflag x y (board : Board) =
  checkState board
  let flags = board.Flags
  let flag = flags.[x, y]
  if flag = Flag then
    flags.[x, y] <- Close
  else
    exc "Can only unflag flags."
  board

/// Toggles a flag.
let toggle x y (board : Board) =
  checkState board
  let flags = board.Flags
  let flag = flags.[x, y]
  if flag = Flag then flags.[x, y] <- Close
  elif flag = Close then flags.[x, y] <- Flag
  else exc "Can't toggle flags on opened squares."
  board

let useSolution board slns =
  for a, (x, y) in slns do
    if board.State = BoardState.Normal then
      let f =
        match a with
        | HasMine -> flag
        | NoMine -> probe
        | _ -> (fun _ _ board -> board)
      f x y board |> ignore

#endregion
#region "Initializers"

/// Constructs a new Board record with empty squares.
let newBoard width height count =
  {
    Flags = bury width height
    Board = Array2D.create width height INVALID
    Width = width
    Height = height
    Count = count
    State = Normal
  }

/// Initializes a new board with specified initial click
let newBoardNow width height count cx cy =
  {
    Flags = bury width height
    Board =
      boolBoard width height count cx cy
      |> labeledBoard width height
    Width = width
    Height = height
    Count = count
    State = Normal
  }

#endregion
